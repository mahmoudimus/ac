package com.atlassian.plugin.connect.test.plugin;

import com.atlassian.applinks.api.ApplicationLink;
import com.atlassian.applinks.api.TypeNotInstalledException;
import com.atlassian.jira.security.auth.trustedapps.KeyFactory;
import com.atlassian.jwt.SigningAlgorithm;
import com.atlassian.jwt.applinks.ApplinkJwt;
import com.atlassian.jwt.applinks.JwtService;
import com.atlassian.jwt.applinks.exception.NotAJwtPeerException;
import com.atlassian.jwt.core.writer.NimbusJwtWriterFactory;
import com.atlassian.jwt.exception.JwtIssuerLacksSharedSecretException;
import com.atlassian.jwt.exception.JwtParseException;
import com.atlassian.jwt.exception.JwtSigningException;
import com.atlassian.jwt.exception.JwtUnknownIssuerException;
import com.atlassian.jwt.exception.JwtVerificationException;
import com.atlassian.jwt.reader.JwtClaimVerifier;
import com.atlassian.jwt.writer.JwtWriterFactory;
import com.atlassian.oauth.Consumer;
import com.atlassian.oauth.consumer.ConsumerService;
import com.atlassian.plugin.Plugin;
import com.atlassian.plugin.connect.plugin.JwtSigningRemotablePluginAccessor;
import com.atlassian.plugin.connect.plugin.applinks.ConnectApplinkManager;
import com.atlassian.plugin.connect.plugin.util.http.HttpContentRetriever;
import com.atlassian.plugin.connect.test.plugin.capabilities.testobjects.PluginForTests;
import com.atlassian.sal.api.user.UserKey;
import com.atlassian.sal.api.user.UserManager;
import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.net.URI;
import java.util.Date;
import java.util.List;
import java.util.Map;

import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.when;

/**
 * This class doesn't test anything on its own. It generates a list of signed URLs as a JSON file that can be used as
 * test input in another framework like ACE (--> /test/jwt_signed_url_interoperability_test.js).
 *
 * To generate the signed URLs directly into ACE, follow these steps:
 * 1/ Set a JVM property -Djwtinteroptest.file={path to ACE}/test/resources/jwt-signed-urls.json, e.g.:
 *    -Djwtinteroptest.file=~/dev/atlassian-connect-express/test/resources/jwt-signed-urls.json
 * 2/ Run this test
 * 3/ Run 'mocha test' in ACE
 */
@RunWith(MockitoJUnitRunner.class)
public class JwtSigningInteroperabilityTest
{
    public static final String SHARED_SECRET = "s0m3-sh@r3d-s3cr37";

    private static class TestJwtService implements JwtService
    {
        private final String sharedSecret;
        private JwtWriterFactory jwtWriterFactory;

        private TestJwtService(String sharedSecret)
        {
            this.sharedSecret = sharedSecret;
            this.jwtWriterFactory = new NimbusJwtWriterFactory();
        }

        @Override
        public boolean isJwtPeer(ApplicationLink applicationLink)
        {
            throw new UnsupportedOperationException();
        }

        @Override
        public ApplinkJwt verifyJwt(String jwt, Map<String, ? extends JwtClaimVerifier> claimVerifiers) throws NotAJwtPeerException, JwtParseException, JwtVerificationException, TypeNotInstalledException, JwtIssuerLacksSharedSecretException, JwtUnknownIssuerException
        {
            throw new UnsupportedOperationException();
        }

        @Override
        public String issueJwt(String jsonPayload, ApplicationLink applicationLink) throws NotAJwtPeerException, JwtSigningException
        {
            return jwtWriterFactory.macSigningWriter(SigningAlgorithm.HS256, sharedSecret).jsonToJwt(jsonPayload);
        }
    }

    private static class SigningTests
    {
        private final List<Map<String, String>> tests = Lists.newArrayList();
        private final String sharedSecret;

        public SigningTests(String sharedSecret)
        {
            this.sharedSecret = sharedSecret;
        }


        public void add(String description, String signedUrl)
        {
            tests.add(ImmutableMap.of("name", description, "url", signedUrl));
        }

        public Appendable toJSON(Appendable out)
        {
            Gson gson = new GsonBuilder().create();
            gson.toJson(ImmutableMap.of("secret", sharedSecret, "tests", tests, "comment", createComment()), out);
            return out;
        }

        private String createComment()
        {
            return "Generated by " + getClass().getCanonicalName() + " on " + new Date();
        }
    }

    private JwtSigningRemotablePluginAccessor signer;
    private Supplier<URI> baseUrlSupplier = Suppliers.ofInstance(URI.create("https://example.com"));
    private URI basePath = URI.create("/test");

    @Mock
    private ConsumerService consumerService;
    @Mock
    private ConnectApplinkManager connectApplinkManager;
    @Mock
    private HttpContentRetriever httpContentRetriever;
    @Mock
    private UserManager userManager;
    @Mock
    private ApplicationLink applicationLink;

    @Before
    public void setup()
    {
        when(consumerService.getConsumer()).thenReturn(Consumer.key("jira:1234-5678-9000").name("whatever").signatureMethod(Consumer.SignatureMethod.HMAC_SHA1).publicKey(new KeyFactory.InvalidPublicKey(new Exception())).build());
        when(userManager.getRemoteUserKey()).thenReturn(new UserKey("123456789"));
        when(connectApplinkManager.getAppLink(anyString())).thenReturn(applicationLink);

        Plugin plugin = new PluginForTests("my-plugin", "My Plugin");

        signer = new JwtSigningRemotablePluginAccessor(plugin,
                baseUrlSupplier,
                new TestJwtService(SHARED_SECRET),
                consumerService,
                connectApplinkManager,
                httpContentRetriever,
                userManager);
    }

    @Test
    public void generateTests() throws Exception
    {
        SigningTests tests = new SigningTests(SHARED_SECRET);

        tests.add("Simple", createAndSign("param", "value"));
        tests.add("Spaces", createAndSign("param", "some spaces in this parameter"));
        tests.add("Asterisk", createAndSign("query", "connect*"));
        tests.add("Unicode", createAndSign("director", "宮崎 駿"));
        tests.add("Comma-delimited", createAndSign("ids", "10,2,20,1"));
        tests.add("Multi-value Comma-delimited", createAndSign("tuples", "1,2,3", "6,5,4", "7,9,8"));
        tests.add("Plus", createAndSign("title", "1 + 1 equals 3"));
        tests.add("JSON Object", createAndSign("json", "{\"key\":\"value\"}"));
        tests.add("JSON Array", createAndSign("json", "[\"val1\",\"val2\"]"));
        tests.add("Single Quotes", createAndSign("quote", "'quoted'"));
        tests.add("Brackets", createAndSign("param", "()"));
        tests.add("Tilde", createAndSign("eta", "in ~3 days"));
        tests.add("RFC-1738 Unsafe", createAndSign("rfc", " <>\"#%{}|\\^~[]`"));
        tests.add("RFC-1738 Reserved", createAndSign("rfc", ";/?:@=&"));
        tests.add("RFC-1738 Special", createAndSign("rfc", "$-_.+!*'(),"));
        tests.add("Empty", createAndSign("notmuch", ""));
        tests.add("Encoded", createAndSign("referrer", "http://from.net/p?x=A+%2B+B&y=%24-_.%2B%21*%27%28%29%2C"));
        tests.add("Multi-value", createAndSign("ids", "1", "10", "-1", "20", "2"));
        tests.add("Multi-value II", createAndSign("ids", ".1", ":1", ":2", ".2"));
        tests.add("Multi-value Unicode", createAndSign("chars", "宮", "崎", "駿"));
        tests.add("Multi-value Empty", createAndSign("c", "", " ", "+", "%20"));
        tests.add("Key RFC-1738 Unsafe", createAndSign("#1", "value"));
        tests.add("Key RFC-1738 Reserved", createAndSign(":1", "value"));
        tests.add("Key RFC-1738 Special", createAndSign("$1", "value"));
        tests.add("Multiple Parameters Simple", createAndSign(ImmutableMap.of("a", new String[] {"x"},
                "b", new String[]{"y"})));
        tests.add("Multiple Multi-value Parameters", createAndSign(ImmutableMap.of("a", new String[] {"x10", "x1"},
                "b", new String[]{"y1", "y10"})));
        tests.add("Multiple Parameters Spaces", createAndSign(ImmutableMap.of("a", new String[] {"one string", "another one"},
                "b", new String[]{"more here", "and yet more"})));
        tests.add("Multiple Parameters Comma-delimited", createAndSign(ImmutableMap.of("a", new String[] {"1,2,3", "4,5,6"},
                "b", new String[]{"a,b,c", "d,e,f"})));
        tests.add("Parameter Order", createAndSign(ImmutableMap.of("a10", new String[] {"1"},
                "a1", new String[]{"2"},
                "b1", new String[]{"3"},
                "b10", new String[]{"4"}
        )));

        write(tests);
    }

    private void write(SigningTests tests) throws IOException
    {
        System.out.println(tests.toJSON(new StringBuilder()));
        String filePath = System.getProperty("jwtinteroptest.file");
        if (null != filePath)
        {
            OutputStreamWriter fileWriter = new OutputStreamWriter(new FileOutputStream(filePath), "UTF-8");
            try
            {
                tests.toJSON(fileWriter);
            }
            finally
            {
                fileWriter.close();
            }
        }
    }

    private String createAndSign(String key, String... values)
    {
        return signer.signGetUrl(basePath, ImmutableMap.of(key, values));
    }

    private String createAndSign(Map<String, String[]> params)
    {
        return signer.signGetUrl(basePath, params);
    }
}
