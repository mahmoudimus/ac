package com.atlassian.plugin.connect.plugin;

import com.atlassian.applinks.api.ApplicationLink;
import com.atlassian.jira.security.auth.trustedapps.KeyFactory;
import com.atlassian.jwt.JwtConstants;
import com.atlassian.jwt.core.HttpRequestCanonicalizer;
import com.atlassian.jwt.httpclient.CanonicalHttpUriRequest;
import com.atlassian.oauth.Consumer;
import com.atlassian.oauth.consumer.ConsumerService;
import com.atlassian.plugin.connect.modules.beans.ConnectAddonBean;
import com.atlassian.plugin.connect.plugin.applinks.ConnectApplinkManager;
import com.atlassian.plugin.connect.util.annotation.ConvertToWiredTest;
import com.atlassian.plugin.connect.api.util.UriBuilderUtils;
import com.atlassian.plugin.connect.spi.util.http.HttpContentRetriever;
import com.atlassian.plugin.connect.util.auth.TestJwtJsonBuilderFactory;
import com.atlassian.plugin.connect.util.auth.TestJwtService;
import com.atlassian.sal.api.user.UserKey;
import com.atlassian.sal.api.user.UserManager;
import com.atlassian.uri.UriBuilder;
import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import org.apache.commons.lang3.StringUtils;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.when;

/**
 * This class doesn't test anything on its own. It generates a list of signed URLs as a JSON file that can be used as
 * test input in another framework like ACE (--> /test/jwt_signed_url_interoperability_test.js).
 * <p/>
 * To generate the signed URLs directly into ACE, follow these steps:
 * 1/ Set a JVM property -Djwtinteroptest.file={path to ACE}/test/resources/jwt-signed-urls.json, e.g.:
 * -Djwtinteroptest.file=~/dev/atlassian-connect-express/test/resources/jwt-signed-urls.json
 * 2/ Run this test
 * 3/ Run 'mocha test' in ACE
 */
@ConvertToWiredTest
@RunWith(MockitoJUnitRunner.class)
public class JwtSigningInteroperabilityTest
{
    public static final String SHARED_SECRET = "s0m3-sh@r3d-s3cr37-s0m3-sh@r3d-s3cr37";

    private static class SignedUrlTest
    {
        private final String name;
        private final String canonicalUrl;
        private final String signedUrl;

        private SignedUrlTest(String name, String canonicalUrl, String signedUrl)
        {
            this.name = name;
            this.canonicalUrl = canonicalUrl;
            this.signedUrl = signedUrl;
        }

        private String getName()
        {
            return name;
        }

        private String getCanonicalUrl()
        {
            return canonicalUrl;
        }

        private String getSignedUrl()
        {
            return signedUrl;
        }
    }

    private static class SigningTests
    {
        private final List<SignedUrlTest> tests = Lists.newArrayList();
        private final String sharedSecret;

        public SigningTests(String sharedSecret)
        {
            this.sharedSecret = sharedSecret;
        }

        public void add(List<SignedUrlTest> signedUrlTest)
        {
            tests.addAll(signedUrlTest);
        }

        public Appendable toJSON(Appendable out)
        {
            Gson gson = new GsonBuilder().create();
            gson.toJson(ImmutableMap.of("secret", sharedSecret, "tests", tests, "comment", createComment()), out);
            return out;
        }

        private String createComment()
        {
            return "Generated by " + getClass().getCanonicalName() + " on " + new Date();
        }
    }

    private JwtSigningRemotablePluginAccessor signer;
    private Supplier<URI> baseUrlSupplier = Suppliers.ofInstance(URI.create("https://example.com"));
    private URI basePath = URI.create("/test");

    @Mock
    private ConsumerService consumerService;
    @Mock
    private ConnectApplinkManager connectApplinkManager;
    @Mock
    private HttpContentRetriever httpContentRetriever;
    @Mock
    private UserManager userManager;
    @Mock
    private ApplicationLink applicationLink;

    @Before
    public void setup()
    {
        when(consumerService.getConsumer()).thenReturn(Consumer.key("jira:1234-5678-9000").name("whatever").signatureMethod(Consumer.SignatureMethod.HMAC_SHA1).publicKey(new KeyFactory.InvalidPublicKey(new Exception())).build());
        when(userManager.getRemoteUserKey()).thenReturn(new UserKey("123456789"));
        when(applicationLink.getProperty(JwtConstants.AppLinks.SHARED_SECRET_PROPERTY_NAME)).thenReturn(SHARED_SECRET);
        when(connectApplinkManager.getAppLink(anyString())).thenReturn(applicationLink);

        ConnectAddonBean addon = ConnectAddonBean.newConnectAddonBean()
                .withKey("my-plugin")
                .withName("My Plugin")
                .withBaseurl("")
                .build();

        signer = new JwtSigningRemotablePluginAccessor(addon,
                baseUrlSupplier,
                new TestJwtJsonBuilderFactory(new SubjectJwtClaimWriter(userManager)),
                new TestJwtService(),
                consumerService,
                connectApplinkManager,
                httpContentRetriever);
    }

    @Test
    public void generateTests() throws Exception
    {
        SigningTests tests = new SigningTests(SHARED_SECRET);

        tests.add(createAndSign("Simple", "param", "value"));
        tests.add(createAndSign("Spaces", "param", "some spaces in this parameter"));
        tests.add(createAndSign("Asterisk", "query", "connect*"));
        tests.add(createAndSign("Unicode", "director", "宮崎 駿"));
        tests.add(createAndSign("Comma-delimited", "ids", "10,2,20,1"));
        tests.add(createAndSign("Multi-value Comma-delimited", "tuples", "1,2,3", "6,5,4", "7,9,8"));
        tests.add(createAndSign("Plus", "title", "1 + 1 equals 3"));
        tests.add(createAndSign("JSON Object", "json", "{\"key\":\"value\"}"));
        tests.add(createAndSign("JSON Array", "json", "[\"val1\",\"val2\"]"));
        tests.add(createAndSign("Single Quotes", "quote", "'quoted'"));
        tests.add(createAndSign("Brackets", "param", "()"));
        tests.add(createAndSign("Tilde", "eta", "in ~3 days"));
        tests.add(createAndSign("RFC-1738 Unsafe", "rfc", " <>\"#%{}|\\^~[]`"));
        tests.add(createAndSign("RFC-1738 Reserved", "rfc", ";/?:@=&"));
        tests.add(createAndSign("RFC-1738 Special", "rfc", "$-_.+!*'(),"));
        tests.add(createAndSign("RFC-3986 Unreserved", "rfc", "-._~"));
        tests.add(createAndSign("RFC-3986 gen-delims", "rfc", ":/?#[]@"));
        tests.add(createAndSign("RFC-3986 sub-delims", "rfc", "!$&'()*+,;="));
        tests.add(createAndSign("Empty", "notmuch", ""));
        tests.add(createAndSign("Encoded", "referrer", "http://from.net/p?x=A+%2B+B&y=%24-_.%2B%21*%27%28%29%2C"));
        tests.add(createAndSign("Multi-value", "ids", "1", "10", "-1", "20", "2"));
        tests.add(createAndSign("Multi-value II", "ids", ".1", ":1", ":2", ".2"));
        tests.add(createAndSign("Multi-value Unicode", "chars", "宮", "崎", "駿"));
        tests.add(createAndSign("Multi-value Empty", "c", "", " ", "+", "%20"));
        tests.add(createAndSign("Key RFC-1738 Unsafe", "#1", "value"));
        tests.add(createAndSign("Key RFC-1738 Reserved", ":1", "value"));
        tests.add(createAndSign("Key RFC-1738 Special", "$1", "value"));
        tests.add(createAndSign("Multiple Parameters Simple", ImmutableMap.of(
                "a", new String[]{"x"},
                "b", new String[]{"y"})));
        tests.add(createAndSign("Multiple Multi-value Parameters", ImmutableMap.of(
                "a", new String[]{"x10", "x1"},
                "b", new String[]{"y1", "y10"})));
        tests.add(createAndSign("Multiple Parameters Spaces", ImmutableMap.of(
                "a", new String[]{"one string", "another one"},
                "b", new String[]{"more here", "and yet more"})));
        tests.add(createAndSign("Multiple Parameters Comma-delimited", ImmutableMap.of(
                "a", new String[]{"1,2,3", "4,5,6"},
                "b", new String[]{"a,b,c", "d,e,f"})));
        tests.add(createAndSign("Parameter Order", ImmutableMap.of(
                "a10", new String[]{"1"},
                "a1", new String[]{"2"},
                "b1", new String[]{"3"},
                "b10", new String[]{"4"})));
        tests.add(createAndSign("Upper- and Lower-case Parameters", ImmutableMap.of(
                "A", new String[]{"A"},
                "a", new String[]{"a"},
                "b", new String[]{"b"},
                "B", new String[]{"B"})));
        tests.add(createAndSign("Search Request View", URI.create("/search-view"), new ImmutableMap.Builder<String, String[]>()
                .put("link", new String[]{"http://ion:2990/jira/secure/IssueNavigator.jspa?reset=true&jqlQuery=issuetype+%3D+Bug"})
                .put("startIssue", new String[]{"0"})
                .put("totalIssues", new String[]{"2"})
                .put("endIssue", new String[]{"2"})
                .put("issues", new String[]{"issues=TEST-2,TEST-1"})
                .put("tz", new String[]{"Australia/Sydney"})
                .put("loc", new String[]{"en-US"})
                .put("user_id", new String[]{"admin"})
                .put("user_key", new String[]{"admin"})
                .put("xdm_e", new String[]{"http://ion.local:2990"})
                .put("xdm_c", new String[]{"channel-acmodule-1564427223927602208"})
                .put("cp", new String[]{"jira"})
                .put("lic", new String[]{"none"})
                .build()
        ));
        tests.add(createAndSign("BasePath only", ImmutableMap.<String,String[]>of()));
        tests.add(createAndSign("BasePath with Delimiter", URI.create("/endsWithDelimiter/"), ImmutableMap.of("a", new String[]{"b"})));
        tests.add(createAndSign("BasePath with Delimiter Only", URI.create("/endsWithDelimiter/"), ImmutableMap.<String,String[]>of()));
        tests.add(createAndSign("BasePath RFC3986 Unreserved", URI.create("/path-._~"), ImmutableMap.of("a", new String[]{"b"})));
        tests.add(createAndSign("BasePath RFC3986 Subdelimiters", URI.create("/path!$&'()*+,;="), ImmutableMap.of("a", new String[]{"b"})));
        write(tests);
    }

    private void write(SigningTests tests) throws IOException
    {
        String filePath = System.getProperty("jwtinteroptest.file");
        if (null != filePath)
        {
            OutputStreamWriter fileWriter = new OutputStreamWriter(new FileOutputStream(filePath), "UTF-8");
            try
            {
                tests.toJSON(fileWriter);
            }
            finally
            {
                fileWriter.close();
            }
        }
    }

    private List<SignedUrlTest> createAndSign(String name, String key, String... values) throws UnsupportedEncodingException
    {
        return createAndSign(name, ImmutableMap.of(key, values));
    }

    private List<SignedUrlTest> createAndSign(String name, Map<String, String[]> params) throws UnsupportedEncodingException
    {
        return createAndSign(name, basePath, params);
    }

    private List<SignedUrlTest> createAndSign(String name, URI basePath, Map<String, String[]> params) throws UnsupportedEncodingException
    {
        ArrayList<SignedUrlTest> tests = Lists.newArrayList();
        tests.add(createAndSignTest(name, basePath, params));
        tests.add(createAndSignTest(name + " (uri)", createURI(basePath, params), ImmutableMap.<String,String[]>of()));
        return tests;
    }

    private SignedUrlTest createAndSignTest(String name, URI basePath, Map<String, String[]> params) throws UnsupportedEncodingException
    {
        HashMap<String, String[]> completeParams = new HashMap<String, String[]>(params);
        if (!StringUtils.isBlank(basePath.getQuery()))
        {
            completeParams.putAll(JwtAuthorizationGenerator.constructParameterMap(basePath));
        }
        String canonicalUrl = HttpRequestCanonicalizer.canonicalize(new CanonicalHttpUriRequest("GET", basePath.getPath(), "", completeParams));
        String signedUrl = signer.signGetUrl(basePath, params);
        return new SignedUrlTest(name, canonicalUrl, signedUrl);
    }

    private URI createURI(URI basePath, Map<String, String[]> params)
    {
        UriBuilder uriBuilder = new UriBuilder()
                .setScheme(basePath.getScheme())
                .setAuthority(basePath.getAuthority())
                .setPath(basePath.getPath());

        UriBuilderUtils.addQueryParameters(uriBuilder, params);

        return uriBuilder.toUri().toJavaUri();
    }
}
